{"content":"<h1 id=\"promise\">promise</h1>\n<blockquote>\n<p><strong>promise A+文档</strong>： <a href=\"https://promisesaplus.com/\">https://promisesaplus.com/</a><br><strong>翻译参考</strong>: <a href=\"https://juejin.cn/post/6844903767654023182\">https://juejin.cn/post/6844903767654023182</a> </p>\n</blockquote>\n<p>一个 promise 代表一个异步操作的最终结果。主要的操作方式是通过调用 promise 的 then 方法，它接受的回调函数接受 promise 成功的结果或失败的原因。  </p>\n<h2 id=\"1-术语\"><strong>1.</strong> 术语:</h2>\n<p>1.1 <strong>promise</strong>：是一个有符合此标准的 then 方法的 object 或 function<br>1.2 <strong>thenable</strong>：是 then 方法定义的 object 或 function<br>1.3 <strong>value</strong>：是一个 JavaScript 合法值（包括 undefined，thenable，promise）<br>1.4 <strong>reason</strong>：是一个表明 promise 失败的原因的值<br>1.5 <strong>exception</strong>：是一个 throw 语句抛出错误的值    </p>\n<h2 id=\"2-promise-状态\"><strong>2.</strong> Promise 状态</h2>\n<ul>\n<li>一个 promise 有且只有一个状态（pending，fulfilled，rejected 其中之一）。   </li>\n<li>promise状态只会从pending-&gt;fulfilled或pending-&gt;rejected</li>\n</ul>\n<h2 id=\"3-then\"><strong>3.</strong> then</h2>\n<ul>\n<li>promise必须有一个then方法  </li>\n<li>then方法有两个可选的函数参数，用于接收promise成功或失败的原因，即：fulfilled状态对应的value，rejected对应的reason</li>\n</ul>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">&#x27;pending&#x27;</span>\n<span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">&#x27;fulfilled&#x27;</span>\n<span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">&#x27;rejected&#x27;</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PromiseA</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">excute</span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (!excute || <span class=\"hljs-keyword\">typeof</span> excute !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) \n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;初始化promise需传入一个函数&quot;</span>)\n    <span class=\"hljs-built_in\">this</span>.state = PENDING\n    <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">undefined</span>\n    <span class=\"hljs-built_in\">this</span>.reason = <span class=\"hljs-literal\">undefined</span>\n    excute(<span class=\"hljs-built_in\">this</span>.resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>.reject.bind(<span class=\"hljs-built_in\">this</span>))\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>)</span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state === PENDING) {\n      <span class=\"hljs-built_in\">this</span>.state = FULFILLED\n      <span class=\"hljs-built_in\">this</span>.value = value;\n    }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>)</span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state === PENDING) {\n      <span class=\"hljs-built_in\">this</span>.state = REJECTED\n      <span class=\"hljs-built_in\">this</span>.reason = reason\n    }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">then</span>(<span class=\"hljs-params\">onFulfilled, onRejected</span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state === FULFILLED) onFulfilled(<span class=\"hljs-built_in\">this</span>.value)\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state === REJECTED) onRejected(<span class=\"hljs-built_in\">this</span>.reason)\n  }\n}\n<span class=\"hljs-comment\">// resolve不是实例调用的，所以在PromiseA里执行时需要绑定this</span>\n<span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> resolve(<span class=\"hljs-number\">1</span>))\np.then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(res))\n<span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>这一版已经实现了状态的改变和值的传递，接下来我们继续深入。   </p>\n<h3 id=\"31-then初步实现\"><strong>3.1.</strong> then初步实现</h3>\n<ul>\n<li>onFulfilled 或 onRejected 只在执行环境堆栈只包含平台代码之后调用，且只调用一次。即在当前任务队列中执行这俩函数，得在下一次事件循环中执行，可以用setTimeout模拟   </li>\n<li>then函数可以多次调用。即链式调用，这里可以定义两个任务队列。  </li>\n<li>then函数一定返回一个pormise</li>\n</ul>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">&#x27;pending&#x27;</span>\n<span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">&#x27;fulfilled&#x27;</span>\n<span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">&#x27;rejected&#x27;</span>\n<span class=\"hljs-keyword\">const</span> isFn = <span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =&gt;</span> <span class=\"hljs-keyword\">typeof</span> fn === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n<span class=\"hljs-comment\">// 异步调用函数，在下一次事件循环调用</span>\n<span class=\"hljs-keyword\">const</span> nextTick = <span class=\"hljs-function\">(<span class=\"hljs-params\">fn, delay=<span class=\"hljs-number\">0</span></span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isFn(fn)) {\n    <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span> {\n      fn()\n      timer = <span class=\"hljs-literal\">null</span>\n      <span class=\"hljs-built_in\">clearTimeout</span>(timer)\n    }, delay)\n  }\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PromiseA</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">excute</span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (!excute || <span class=\"hljs-keyword\">typeof</span> excute !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) \n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;初始化promise需传入一个函数&quot;</span>)\n    <span class=\"hljs-built_in\">this</span>.state = PENDING\n    <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">undefined</span>\n    <span class=\"hljs-built_in\">this</span>.reason = <span class=\"hljs-literal\">undefined</span>\n    <span class=\"hljs-built_in\">this</span>.onFulfilledTasks = [];\n    <span class=\"hljs-built_in\">this</span>.onRejectedTasks = [];\n    <span class=\"hljs-keyword\">try</span> {\n      excute(<span class=\"hljs-built_in\">this</span>.resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>.reject.bind(<span class=\"hljs-built_in\">this</span>))\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n      <span class=\"hljs-built_in\">this</span>.reject(error)\n    }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>)</span>{\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state === PENDING) {\n        <span class=\"hljs-built_in\">this</span>.state = FULFILLED\n        <span class=\"hljs-built_in\">this</span>.value = value;\n        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">this</span>.onFulfilledTasks.length) {\n          <span class=\"hljs-keyword\">let</span> cb = <span class=\"hljs-built_in\">this</span>.onFulfilledTasks.shift()\n          cb &amp;&amp; cb()\n        }\n      }\n    } \n    <span class=\"hljs-comment\">// 保证promise代码的同步执行，then回调函数采用异步的方式调用</span>\n    <span class=\"hljs-comment\">// 在resolve里调用task出队后的函数，实现链式调用</span>\n    nextTick(run)\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>)</span>{\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state === PENDING) {\n        <span class=\"hljs-built_in\">this</span>.state = REJECTED\n        <span class=\"hljs-built_in\">this</span>.reason = reason\n        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">this</span>.onRejectedTasks.length) {\n          <span class=\"hljs-keyword\">let</span> cb = <span class=\"hljs-built_in\">this</span>.onRejectedTasks.shift()\n          cb &amp;&amp; cb()\n        }\n      }\n    }\n    nextTick(run)\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">then</span>(<span class=\"hljs-params\">onFulfilled, onRejected</span>)</span> {\n    <span class=\"hljs-keyword\">const</span> {state, value, reason} = <span class=\"hljs-built_in\">this</span>;\n    <span class=\"hljs-keyword\">switch</span> (state) {\n      <span class=\"hljs-keyword\">case</span> PENDING:\n        onFulfilled &amp;&amp; <span class=\"hljs-built_in\">this</span>.onFulfilledTasks.unshift(onFulfilled)\n        onRejected &amp;&amp; <span class=\"hljs-built_in\">this</span>.onRejectedTasks.unshift(onRejected)\n        <span class=\"hljs-keyword\">break</span>;\n      <span class=\"hljs-keyword\">case</span> FULFILLED:\n        onFulfilled(value)\n        <span class=\"hljs-keyword\">break</span>;\n      <span class=\"hljs-keyword\">case</span> REJECTED:\n        onRejected(reason)\n        <span class=\"hljs-keyword\">break</span>;\n      <span class=\"hljs-keyword\">default</span>:\n        <span class=\"hljs-keyword\">break</span>;\n    }\n    <span class=\"hljs-comment\">// 返回promiseA，具体要往下传递的值看后面的分析</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\">() =&gt;</span> {})\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n  resolve(<span class=\"hljs-number\">1</span>)\n})\np.then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>,res)).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>,res)).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>,res))\n<span class=\"hljs-comment\">// 1.此时的p是fulfilled状态</span>\n<span class=\"hljs-comment\">// 2.返回新的pending状态的PromiseA实例</span>\n<span class=\"hljs-comment\">// 3.返回新的pending状态的PromiseA实例</span>\n</code></pre>\n<p>上面实现了then的链式调用。<br><strong>Tips</strong>：有一个问题，就是在后续PromisA的实例都是peding状态，而且由于then返回的promiseA实例中的初始化函数没有参数，接收不了上一个实例执行返回的值，只能透传第一个实例resolve的值。所以，下面就进入then的具体分析，即[[Resolve]](promise, x) 处理解析</p>\n<h3 id=\"32-then的具体逻辑\"><strong>3.2</strong> then的具体逻辑</h3>\n<p><strong>then(onFulfilled, onRejected)</strong>    </p>\n<ul>\n<li>onFulfilled,onRejected不为函数时，透传上一次resolve的值；   </li>\n<li>如果返回的 promise1 和 x 是指向同一个引用（循环引用），则抛出错误；   </li>\n<li>如果 x 是一个 promise 实例，则采用它的状态；   </li>\n<li>如果 then 是函数类型，那个用 x 调用它（将 then 的 this 指向 x， 避免object.defineProperty中get()带来的副作用）,第一个参数传 resolvePromise ，第二个参数传 rejectPromise    </li>\n<li>如果 x 即不是函数类型也不是对象类型，直接 resolve x（resolve(x)）<br>具体可以见代码注释：</li>\n</ul>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">&#x27;pending&#x27;</span>\n<span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">&#x27;fulfilled&#x27;</span>\n<span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">&#x27;rejected&#x27;</span>\n<span class=\"hljs-keyword\">const</span> isFn = <span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =&gt;</span> <span class=\"hljs-keyword\">typeof</span> fn === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n<span class=\"hljs-keyword\">const</span> nextTick = <span class=\"hljs-function\">(<span class=\"hljs-params\">fn, delay=<span class=\"hljs-number\">0</span></span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isFn(fn)) {\n    <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span> {\n      fn()\n      timer = <span class=\"hljs-literal\">null</span>\n      <span class=\"hljs-built_in\">clearTimeout</span>(timer)\n    }, delay)\n  }\n}\n<span class=\"hljs-keyword\">const</span> isObj = <span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =&gt;</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj) === <span class=\"hljs-string\">&quot;[object Object]&quot;</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PromiseA</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">excute</span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (!excute || <span class=\"hljs-keyword\">typeof</span> excute !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) \n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;初始化promise需传入一个函数&quot;</span>)\n    <span class=\"hljs-built_in\">this</span>.state = PENDING\n    <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">undefined</span>\n    <span class=\"hljs-built_in\">this</span>.reason = <span class=\"hljs-literal\">undefined</span>\n    <span class=\"hljs-built_in\">this</span>.onFulfilledTasks = [];\n    <span class=\"hljs-built_in\">this</span>.onRejectedTasks = [];\n    <span class=\"hljs-keyword\">try</span> {\n      excute(<span class=\"hljs-built_in\">this</span>.resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>.reject.bind(<span class=\"hljs-built_in\">this</span>))\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n      <span class=\"hljs-built_in\">this</span>.reject(error)\n    }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>)</span>{\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state !== PENDING) <span class=\"hljs-keyword\">return</span>\n      <span class=\"hljs-keyword\">const</span> onResolve = <span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">this</span>.onFulfilledTasks.length) {\n          <span class=\"hljs-keyword\">let</span> cb = <span class=\"hljs-built_in\">this</span>.onFulfilledTasks.shift()\n          cb &amp;&amp; cb(val)\n        }\n      }\n      <span class=\"hljs-keyword\">const</span> onReject = <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">this</span>.onRejectedTasks.length) {\n          <span class=\"hljs-keyword\">let</span> cb = <span class=\"hljs-built_in\">this</span>.onRejectedTasks.shift()\n          cb &amp;&amp; cb(err)\n        }\n      }\n      <span class=\"hljs-comment\">/** \n       * 如果value为promise则需要等待Promise对象状态改变后，\n       * 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态，\n       * 将参数promise返回值向下传递\n       * */</span> \n\n      <span class=\"hljs-keyword\">if</span> (value <span class=\"hljs-keyword\">instanceof</span> PromiseA) {\n        value.then(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n          <span class=\"hljs-built_in\">this</span>.state = FULFILLED\n          <span class=\"hljs-built_in\">this</span>.value = val;\n          onResolve(val)\n        }, <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n          <span class=\"hljs-built_in\">this</span>.state = REJECTED\n          <span class=\"hljs-built_in\">this</span>.reason = err\n          onReject(err)\n        })\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">this</span>.state = FULFILLED\n        <span class=\"hljs-built_in\">this</span>.value = value;\n        onResolve(value)\n      }\n    }\n    <span class=\"hljs-comment\">// 保证promise代码的同步执行，then回调函数采用异步的方式调用</span>\n    <span class=\"hljs-comment\">// 在resolve里调用task出队后的函数，实现链式调用</span>\n    nextTick(run)\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>)</span>{\n    <span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state === PENDING) {\n        <span class=\"hljs-built_in\">this</span>.state = REJECTED\n        <span class=\"hljs-built_in\">this</span>.reason = reason\n        <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">this</span>.onRejectedTasks.length) {\n          <span class=\"hljs-keyword\">let</span> cb = <span class=\"hljs-built_in\">this</span>.onRejectedTasks.shift()\n          cb &amp;&amp; cb(reason)\n        }\n      }\n    }\n    nextTick(run)\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">then</span>(<span class=\"hljs-params\">onFulfilled, onRejected</span>)</span> {\n    <span class=\"hljs-keyword\">const</span> {state, value, reason} = <span class=\"hljs-built_in\">this</span>;\n    <span class=\"hljs-comment\">// 因为传入的是一个立即执行函数，所以处理逻辑可以放在里面</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolveNext, rejectNext</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 重新封装一下resolveNext,处理onFulfilled的返回值，用于向下传递</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (!isFn(onFulfilled)) {\n          resolveNext &amp;&amp; resolveNext(val)\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-keyword\">let</span> res = onFulfilled(val)\n          <span class=\"hljs-keyword\">if</span> (res === <span class=\"hljs-built_in\">this</span>) {<span class=\"hljs-comment\">// 2.3.1 如果返回的 promise1 和 x 是指向同一个引用（循环引用），则抛出错误</span>\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;两个实例指向了同一个引用&quot;</span>)\n          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> PromiseA) {<span class=\"hljs-comment\">// 如果 x 是一个 promise 实例，则采用它的状态</span>\n            res.then(resolveNext, rejectNext)\n          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isObj(res) || <span class=\"hljs-keyword\">typeof</span> res === <span class=\"hljs-string\">&quot;function&quot;</span>) { <span class=\"hljs-comment\">// 如果 x 是个对象或函数类型</span>\n            <span class=\"hljs-keyword\">const</span> _then = res.then || res;\n            <span class=\"hljs-keyword\">try</span> {\n              _then(resolveNext, rejectNext)\n            } <span class=\"hljs-keyword\">catch</span> (error) {\n              rejectNext(error)\n            }\n          } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">//如果 x 即不是函数类型也不是对象类型</span>\n            resolveNext(res)\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">const</span> _reject = <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">const</span> _this = <span class=\"hljs-built_in\">this</span>\n        <span class=\"hljs-keyword\">if</span> (!isFn(onRejected)) {\n          rejectNext &amp;&amp; rejectNext(val)\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-keyword\">let</span> res = onRejected(val)\n          <span class=\"hljs-keyword\">if</span> (res === _this ) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;两个实例指向了同一个引用&quot;</span>)\n          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> PromiseA) {\n            res.then(resolveNext, rejectNext)\n          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isObj(res) || <span class=\"hljs-keyword\">typeof</span> res === <span class=\"hljs-string\">&quot;function&quot;</span>) {\n            <span class=\"hljs-keyword\">const</span> _then = res.then || res\n            <span class=\"hljs-keyword\">try</span> {\n              _then(resolveNext, rejectNext)\n            } <span class=\"hljs-keyword\">catch</span> (error) {\n              rejectNext(error)\n            }\n          } <span class=\"hljs-keyword\">else</span> {\n            rejectNext(res)\n          }\n        }\n      }\n      <span class=\"hljs-keyword\">switch</span> (state) {\n        <span class=\"hljs-keyword\">case</span> PENDING:\n          <span class=\"hljs-built_in\">this</span>.onFulfilledTasks.push(_resolve)\n          <span class=\"hljs-built_in\">this</span>.onRejectedTasks.push(_reject)\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> FULFILLED:\n          _resolve(value)\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> REJECTED:\n          _reject(reason)\n          <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">default</span>:\n          <span class=\"hljs-keyword\">break</span>;\n      }\n    })\n  }\n}\n</code></pre>\n<h3 id=\"用例\">用例</h3>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> resolve(<span class=\"hljs-number\">1</span>))\n<span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;p1&quot;</span>)\n    resolve(<span class=\"hljs-number\">8</span>)\n  }, <span class=\"hljs-number\">1000</span>)\n})\n<span class=\"hljs-comment\">// A</span>\np.then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">0</span>, res)\n  <span class=\"hljs-keyword\">return</span> p1\n<span class=\"hljs-comment\">// B</span>\n}).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>, res)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>\n<span class=\"hljs-comment\">// C</span>\n}).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>,res)\n})\n\n<span class=\"hljs-comment\">// D</span>\np.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">0</span>, res)\n})\n<span class=\"hljs-comment\">// 0 1</span>\n<span class=\"hljs-comment\">// 0 1</span>\n<span class=\"hljs-comment\">// 1 p1 ----1s后打印</span>\n<span class=\"hljs-comment\">// 2 8</span>\n<span class=\"hljs-comment\">// 3 5</span>\n</code></pre>\n<p>用例的执行顺序： </p>\n<blockquote>\n<p>首先要明确，then执行后返回的是一个新的PromiseA对象，所以对于同一条then的链式调用，<strong>上一个对象的onFulfilledTasks只保存了下一个then的onFulffild函数</strong>。<br>其次，onFulfilledTasks的调用是在p对象resolve或reject后才会调用，如果没有resolve或reject，列表中的函数始终触发不了，这也就是链式调用的关键    </p>\n</blockquote>\n<p><strong>1.</strong>  p创建成功后，resolve(1)为入口，因为这里是在setTimeout中执行，所以当前的state为pengding，在then函数中，直接push回调到p对象的onFulfilledTasks中，在下一次事件循环的时候，执行onFulfilledTasks中的函数，接着往下<br><strong>2.</strong> 第一轮同步链式调用，总共3个对象，各自对应的onFulfilledTasks分别为： [A, D], [ B ], [ C ]<br><strong>3.</strong> 这时链式调用的同步过程执行完了，开始下一次事件循环，调用p对象上onFulfilledTasks中的函数<br><strong>4.</strong> A和D的console在接到res后，直接打印了，但是A中返回了一个promise，所以这时命中then函数中的条件，调用p1.then()。将后面的then的回调函数fulffild写入p1的onFulfilledTasks中<br><strong>4.</strong> p1的resolve执行后，讲p1返回的值往下传递，进入下一次事件循环，执行p1中的onFulfilledTasks<br><strong>5.</strong> 后续的then就是正常的返回值，在执行rejectNext(res)后，向下传递值。   </p>\n<h3 id=\"promise静态方法实现\">Promise静态方法实现</h3>\n<ul>\n<li><p>resolve方法    </p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">static</span> resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> {\n<span class=\"hljs-keyword\">if</span> (value <span class=\"hljs-keyword\">instanceof</span> PromiseA) <span class=\"hljs-keyword\">return</span> value;\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> resolve(value))\n}\n</code></pre>\n</li>\n<li><p>reject方法     </p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">static</span> reject = <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n<span class=\"hljs-keyword\">if</span> (err <span class=\"hljs-keyword\">instanceof</span> PromiseA) <span class=\"hljs-keyword\">return</span> err;\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> reject(err))\n}\n</code></pre>\n</li>\n<li><p>all方法     </p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">static</span> all = <span class=\"hljs-function\"><span class=\"hljs-params\">plist</span> =&gt;</span> {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> values = [];\n  <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n  plist.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">p, index</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// 调用静态方法resolve，保证返回的始终是一个promiseA</span>\n    <span class=\"hljs-built_in\">this</span>.resolve(p).then(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n      values[index] = val;\n      count += <span class=\"hljs-number\">1</span>\n      <span class=\"hljs-keyword\">if</span> (count === plist.length) resolve(values)\n    }, <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 有一个reject，则返回的状态就为rejected</span>\n      reject(err)\n    })\n  });\n})\n}\n</code></pre>\n</li>\n<li><p>race方法     </p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">static</span> race = <span class=\"hljs-function\"><span class=\"hljs-params\">plist</span> =&gt;</span> {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> PromiseA(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 有一个实例改变状态，新的promiseA实例就跟着改变</span>\n  plist.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">p</span>) =&gt;</span> {\n    <span class=\"hljs-built_in\">this</span>.resolve(p).then(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n      resolve(val)\n    }, <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      reject(err)\n    })\n  });\n})\n}\n</code></pre>\n</li>\n</ul>\n","fileName":"promise"}