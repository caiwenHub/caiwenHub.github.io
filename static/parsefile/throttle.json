{"content":"<h1 id=\"节流函数\">节流函数</h1>\n<h2 id=\"介绍\">介绍</h2>\n<p><strong>定义</strong>：把一段时间分成多个切片，在这些切片里面多次触发只执行一次。<br><strong>场景</strong>：按钮连续点击、事件监听（resize...）等防止事件频繁触发的场景。  </p>\n<h2 id=\"实现\">实现</h2>\n<ul>\n<li>第一种实现方式<br>```js\n/**</li>\n</ul>\n<ul>\n<li>节流函数</li>\n<li>@param {*} fn </li>\n<li>@param {*} delay </li>\n<li>@param {*} immediate 是否先执行</li>\n<li>@returns</li>\n</ul>\n<p> */\nconst throttle = (fn, delay, immediate) =&gt; {\n  let timer = null;\n  const throttleFn = (...args) =&gt; {\n    if (timer) return;\n    if (immediate) {\n      fn(...args)\n      timer = setTimeout(() =&gt; {\n        timer = null;\n      }, delay)\n    } else {\n      timer = setTimeout(() =&gt; {\n        fn(...args)\n        clearTimeout(timer)\n        timer = null;\n      }, delay)\n    }\n  }\n  return throttleFn\n}</p>\n<pre><code>\n- 第二种实现方式   \n```js\nconst throttle2 = (fn, delay) =&gt; {\n  let timer = null\n  const throttle2Fn = (...args) =&gt; {\n    const curTime = new Date().getTime()\n    if (!timer) timer = curTime\n    if ((curTime - timer) &lt;= delay) return\n    fn(...args)\n    timer = null\n  }\n  return throttle2Fn\n}\n</code></pre>\n<p>第一种方式，在停止事件触发后，定时器还没有清除，所以还会在执行一次<br>第二种方式，在停止事件触发后，不会再继续执行最后一次操作，但是每一次触发都是先执行一次。</p>\n<h2 id=\"用例\">用例</h2>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> handleMouseMove = <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;throttle&#x27;</span>)\n}\n<span class=\"hljs-keyword\">const</span> handleMouseMoveThrottle = throttle2(handleMouseMove, <span class=\"hljs-number\">1000</span>, <span class=\"hljs-literal\">true</span>)\n<span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;mousemove&quot;</span>, handleMouseMoveThrottle, <span class=\"hljs-literal\">false</span>)\n</code></pre>\n","fileName":"throttle"}