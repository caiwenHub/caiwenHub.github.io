{"content":"<h1 id=\"https\">https</h1>\n<h2 id=\"osi-五层模型\">OSI 五层模型</h2>\n<blockquote>\n<p>应用层： http, https, ftp, ws, wss<br>表示层<br>会话层： ssl/tls<br>传输层： tcp, udp<br>网络层： ip<br>数据链路层： 交换机<br>物理层： 主要定义物理设备标准：网线接口，光纤接口</p>\n</blockquote>\n<h2 id=\"http-和-https-的区别\">http 和 https 的区别</h2>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>http</th>\n<th>https</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>端口号</td>\n<td>80</td>\n<td>443</td>\n</tr>\n<tr>\n<td>证书</td>\n<td>不需要</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>建立连接</td>\n<td>tcp 三次握手</td>\n<td>tcp 三次握手成功后，需要再 ssl/tls 四次握手加密</td>\n</tr>\n</tbody></table>\n<h2 id=\"https-建立连接\">https 建立连接</h2>\n<p>https 在 tcp 连接成功后，还需要进行 ssl/tls 协议加密，基于加密算法包括： 散列函数 hash、对称加密、非对称加密</p>\n<ul>\n<li><p>tcp 流程</p>\n<pre><code class=\"hljs mermaid\">sequenceDiagram\n\nparticipant A as 客户端\nparticipant B as 服务端\n\nA -&gt;&gt; B: 1. SYN=1, seq=x\nB -&gt;&gt; A: 2. SYN=1, ack=x+1, seq=y\nA -&gt;&gt; B: 3. ack=y+1\n</code></pre>\n<p>ACK: 应答<br>SYN： 同步，表示开始会话请求<br>seq：一个数据段的第一个序列号</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>ssl/tls 流程</p>\n<pre><code class=\"hljs mermaid\">sequenceDiagram\n\nparticipant A as 客户端\nparticipant B as 服务端\n\nA -&gt;&gt; B: 1.（请求）证书、公钥、客户端支持的加密算法、随机数（用于生成“对话密钥”）\nB --&gt; B: 判断是否支持客户端加密算法，申请证书，生成私钥、公钥，随机数\nB -&gt;&gt; A: 2.（应答）包含公钥的证书，随机数，支持加密算法\nA --&gt; A: 判断证书是否有效、过期、生成随机数（公钥加密），用三个随机数生成对话密钥\nA -&gt;&gt; B: 3. 公钥加密的随机数，客户端连接结束\nB --&gt; B: 私钥解随机数，用三个随机数生成对话密钥\nB -&gt;&gt; A: 4. 服务端连接结束\n</code></pre>\n</li>\n</ul>\n<p>1: 私钥只有服务端才有，用来解开公钥加密信息<br>2: 头两个随机数都是明文传输，第三个随机数用公钥加密<br>3: 随机数生成的“对话密钥”加密数据，公钥加密对话密钥</p>\n<ul>\n<li><p>如何保证公钥不被篡改？</p>\n<p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>\n</li>\n<li><p>公钥加密计算量太大，如何减少耗用的时间？</p>\n<p>每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于&quot;对话密钥&quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p>\n</li>\n</ul>\n","fileName":"https"}