{"content":"<h1 id=\"redux\">redux</h1>\n<h2 id=\"解决的问题\">解决的问题</h2>\n<p>解决组件之间通信问题，store是一个全局的数据仓库，state存放数据，且全局只有一个共享state。为了方便state的维护，state下面可以分为多个modal。通俗点讲，store就是一个对象，有一个属性state，和几个方法来操作state。通过观察者模式，当state数据发生改变时，通知所有观察者执行更新</p>\n<h2 id=\"createstore\">createStore</h2>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**\n *  reducer 是一个纯函数，接收旧的state，和action，返回新的state\n *  action 是一个对象，表示当前执行的什么操作 \n */</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createStore</span>(<span class=\"hljs-params\">reducer, initState</span>) {\n    <span class=\"hljs-keyword\">let</span> state = initState;  <span class=\"hljs-comment\">// 全局state，不允许直接赋值</span>\n    <span class=\"hljs-keyword\">const</span> listeners = [];    <span class=\"hljs-comment\">// 存放订阅方法</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getState</span> = (<span class=\"hljs-params\"></span>) =&gt; {};  <span class=\"hljs-comment\">// 获取state</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dispatch</span> = (<span class=\"hljs-params\"></span>) =&gt; {};  <span class=\"hljs-comment\">// 触发数据更新</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">subscrible</span> = (<span class=\"hljs-params\"></span>) =&gt; {}; <span class=\"hljs-comment\">// 订阅消息</span>\n\n    <span class=\"hljs-keyword\">return</span> {getState, dispatch, subscrible}\n}\n</code></pre>\n<h2 id=\"createstore具体实现\">createStore具体实现</h2>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createStore</span>(<span class=\"hljs-params\">reducer, initState</span>) {\n    <span class=\"hljs-keyword\">let</span> state = initState;\n    <span class=\"hljs-keyword\">const</span> listeners = [];\n    \n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getState</span> = (<span class=\"hljs-params\"></span>) =&gt; state;\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dispatch</span> = (<span class=\"hljs-params\">action</span>) =&gt; {\n        state = <span class=\"hljs-title function_\">reducer</span>(state, action)\n        \n        listeners.<span class=\"hljs-title function_\">foreach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =&gt;</span> fn &amp;&amp; <span class=\"hljs-title function_\">fn</span>())\n    };\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">subscrible</span> = fn =&gt; listeners.<span class=\"hljs-title function_\">push</span>(fn);\n\n    <span class=\"hljs-keyword\">return</span> {getState, dispatch, subscrible}\n}\n</code></pre>\n<h2 id=\"reducer方法的实现\">reducer方法的实现</h2>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">Object</span>} state 更新之前的state\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">Object</span>} action 描述此次更新\n * <span class=\"hljs-doctag\">@returns</span> 新的state\n */</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">countReducer</span> = (<span class=\"hljs-params\">state, action</span>) =&gt; {\n    <span class=\"hljs-keyword\">switch</span> (action.<span class=\"hljs-property\">type</span>) {\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;add&quot;</span>:\n            <span class=\"hljs-keyword\">return</span> {...state, <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">count</span> + <span class=\"hljs-number\">1</span>} \n        <span class=\"hljs-attr\">default</span>:\n            <span class=\"hljs-keyword\">return</span> state\n    }\n}\n</code></pre>\n<h2 id=\"combinereducers：state拆分后，合并reducer\">combineReducers：state拆分后，合并reducer</h2>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> initState = {\n    <span class=\"hljs-attr\">info</span>: infoReducer,\n    <span class=\"hljs-attr\">counter</span>: counterReducer\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">combineReducers</span>(<span class=\"hljs-params\">reducers</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reducerFn</span>(<span class=\"hljs-params\">state, action</span>) {\n        <span class=\"hljs-keyword\">const</span> newState = {};\n        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">enties</span>(reducers).<span class=\"hljs-title function_\">foreach</span>(item) =&gt; {\n            <span class=\"hljs-keyword\">const</span> [key, reducer] = item;\n            newState[key] = <span class=\"hljs-title function_\">reducer</span>(state, action)\n        })\n        <span class=\"hljs-keyword\">return</span> newState;\n    }\n}\n</code></pre>\n<h2 id=\"中间件\">中间件</h2>\n<p>类似拦截操作，比如A-&gt;B之间加入一个中间件C，C可以处理其他逻辑，也可以修改A-&gt;B之间的数据，但也应该为纯函数，不更改原有的逻辑，输入即输出。</p>\n<p>函数柯里化（颗粒化）：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>\n<p>多个中间件的串联处理，比如[X, Y, Z]，需要依赖上一个的结果，如：X(Y(Z(next)))</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">X</span> = next =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>,next)\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Y</span> = next =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>,next)\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Z</span> = next =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>,next)\n<span class=\"hljs-keyword\">const</span> funs = [X, Y, Z]\n\n<span class=\"hljs-comment\">//js reduce() 可以作为一个高阶函数，用于函数的 compose。</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">compose</span>(<span class=\"hljs-params\">...funs</span>) {\n  <span class=\"hljs-keyword\">if</span> (funs.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">return</span> funs[<span class=\"hljs-number\">0</span>]\n  }\n  <span class=\"hljs-keyword\">return</span> funs.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> <span class=\"hljs-title function_\">a</span>(<span class=\"hljs-title function_\">b</span>(...args)))\n}\n</code></pre>\n","fileName":"redux"}